<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />

        <!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
        Remove this if you use the .htaccess -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

        <title>index</title>
        <meta name="description" content="" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <!-- Replace favicon.ico & apple-touch-icon.png in the root of your domain and delete these references -->
        <link rel="shortcut icon" href="/favicon.ico" />
        <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
        <style type="text/css">
            * { margin:0; padding:0; }
        </style>
    </head>

    <body style="overflow: hidden;">
        <script type="text/javascript" src="src/three.min.js"></script>
        <script type="text/javascript">
        	// Camera controls
        	var mouse = {x:0,y:0};
        	var dragStarted = false;
        	var zoomDelta = 0;
        	var lastPoint = {x:0,y:0};
        	var moved = {x:0,y:0};
        	var offsetY = -280;
            window.onmousewheel = function(e) {
                var delta = e.wheelDelta;
                zoomDelta = delta / Math.abs(delta) * 50;
            };
            window.onmousedown = function(e) {
            	lastPoint = {
            		x: e.pageX,
            		y: e.pageY
            	};
            	dragStarted = true;
            	zoomDelta = 0;
            }
            window.onmousemove = function(e) {
            	if(!dragStarted) {
            		return true;
            	}
            	moved.x += e.pageX - lastPoint.x;
            	moved.y += e.pageY - lastPoint.y;
            	lastPoint = {
            		x: e.pageX,
            		y: e.pageY
            	};
            }
            window.onmouseup = function(e) {
            	dragStarted = false;
            }
            var direction = 0,
            	rotation = -890,
            	speed = 0,
            	speedLimit = 10,
            	forward = false,
            	elapsed = 0,
            	acceleration = 0.2,
            	rotationVelocity = 3,
            	handbrakeVelocity = 1,
            	oldForward = 0;
            	
            window.onkeydown = function(e) {
            	if({37:-1,39:1}[e.which]) {
            		direction = -{37:-1,39:1}[e.which];
            	}
            	if({38:1,40:-1}[e.which]) {
            		forward = oldForward = {38:1,40:-1}[e.which];
            	}
            	if(e.which == 32) {
            		handbrakeVelocity = 2;
            		forward = 0;
            	}
            }
            window.onkeyup = function(e) {
            	if({37:-1,39:1}[e.which]) {
            		direction = 0;
            	}
            	if({38:1,40:-1}[e.which]) {
            		forward = oldForward = 0;
            	}
            	if(e.which == 32) {
            		handbrakeVelocity = 1;
            		forward = oldForward;
            	}
            }
            
            var animate = function(lastTime, three) {
                var now = Date.now();
                var diff = now - lastTime;
				var car = three.car;
				var body = three.body;
                elapsed += diff;
				
				if(forward) {
					speed = Math.min(speedLimit, Math.max(-speedLimit / 2, speed + forward * acceleration));
				} else if(speed) {
					speed -= (speed > 0) ? acceleration : -acceleration;
					if(speed > 0 && speed < acceleration) speed = 0;
				}
				rotation += direction * speed * rotationVelocity;
				
				var angle = rotation / (Math.PI * 180) + Math.PI / 2;
				var carAngle = (rotation * handbrakeVelocity) / (Math.PI * 180) + Math.PI / 2;
				var posX = Math.cos(angle) * speed;
				var posY = Math.sin(angle) * speed;
				
				car.rotation.z = carAngle;
				
				//body.rotation.y = posX * 0.1;
				body.rotation.x = direction * 0.2;
				
				car.position.x += posX;
				car.position.y += posY;
                
                if(zoomDelta) {
                	zoomDelta -= zoomDelta > 0 ? 1 : -1;
                	three.camera.position.y += zoomDelta * 0.1;
                	three.camera.position.z -= zoomDelta * 0.1;
                	offsetY = three.camera.position.y;
                }
                lastTime = now;
                
                three.renderer.render(three.scene, three.camera);
                
                window.requestAnimationFrame(function() {
                    animate(lastTime, three);
                })
            };
            
            window.onload = function() {
                var supportsWebgl = navigator.userAgent.match(/(iphone|ipad|opera)/i);
                var renderClass = supportsWebgl ? 'CanvasRenderer' : 'WebGLRenderer';
                
                var renderer = new THREE[renderClass]();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
         
                var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
                camera.position.y = -350;
                camera.position.z = 300;
                camera.rotation.x = 45 * (Math.PI / 180);
         
                var scene = new THREE.Scene();
                
                var body = buildCube();
                var car = new THREE.Mesh(new THREE.Geometry());
                car.add(body);
                
                scene.add(car);
                
                var three = {
                    renderer: renderer,
                    camera: camera,
                    scene: scene,
                    car: car,
                    body: body
                };
                window.three = three;
                
                animate(0, three);
            }
            
            function buildCube(idx, len) {
                var materials = [];
                for(var i = 0; i < 6; i++) {
                    var c = Math.random() * 0xFFFFFF << 0;
                    materials.push(new THREE.MeshBasicMaterial({
                        color: c
                    }));
                }
                var size = 50;
                var cube = new THREE.Mesh(new THREE.CubeGeometry(size * 1.5, size, size / 2, 10, 10, 1), new THREE.MeshFaceMaterial(materials));
                cube.overdraw = true;
                return cube
            }
        </script>
    </body>
</html>
